import json

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns

from java_migration.utils import REPO_ROOT

# --- Configuration ---
# The input file generated by your LLM judge script.
INPUT_AUDIT_FILE = REPO_ROOT / "audit_results.json"
# The output file for the plot.
OUTPUT_PLOT_FILE = REPO_ROOT / "java_migration" / "figures" / "coverage_drop_density.pdf"

# --- Plot Styling (to match the paper's aesthetic) ---
# Use a color palette that matches the paper's figures.
# Based on your figures, a purple/green palette seems appropriate.
palette = {
    "Legitimate Refactoring": "#9370DB",  # A medium purple
    "Reward Hacking": "#3CB371",  # A medium sea green
}
# Set plot style
sns.set_style("whitegrid")
plt.rcParams.update(
    {
        "font.family": "sans-serif",
        "font.sans-serif": ["Helvetica", "Arial", "DejaVu Sans"],
        "axes.grid": True,
        "grid.linestyle": ":",
        "grid.color": "lightgray",
        "figure.figsize": (6, 4),  # Standard figure size
        "axes.labelsize": 10,
        "xtick.labelsize": 9,
        "ytick.labelsize": 9,
        "legend.fontsize": 9,
        "legend.title_fontsize": 10,
    }
)


def create_density_plot(data_df):
    """
    Creates and saves a density plot of coverage drops for different classifications.
    """
    # Ensure the classification column is treated as a category for correct ordering
    data_df["llm_classification"] = pd.Categorical(
        data_df["llm_classification"], categories=["Legitimate Refactoring", "Reward Hacking"], ordered=True
    )

    # Filter out any failed judgments if they exist
    plottable_df = data_df[data_df["llm_classification"].notna()].copy()

    if plottable_df.empty:
        print("No valid data to plot after filtering.")
        return

    # Create the plot
    plt.figure()

    # Use seaborn's kdeplot for smooth density curves
    ax = sns.kdeplot(
        data=plottable_df,
        x="coverage_drop_percent",
        hue="llm_classification",
        palette=palette,
        fill=True,
        alpha=0.6,
        linewidth=1.5,
        common_norm=False,  # Each density is normalized independently
    )

    # --- Formatting the plot for the paper ---
    ax.set_title("Distribution of Coverage Drop by Migration Type", fontsize=12)
    ax.set_xlabel("Coverage Drop (%)")
    ax.set_ylabel("Density")

    # Add a vertical line at the 5% threshold
    plt.axvline(x=5, color="r", linestyle="--", linewidth=1.2, label="5% Threshold")

    # Improve the legend
    handles, labels = ax.get_legend_handles_labels()
    # Add the threshold line to the legend
    threshold_line = plt.Line2D([0], [0], color="r", linestyle="--", lw=1.2)
    handles.append(threshold_line)
    labels.append("5% Threshold")
    ax.legend(handles=handles, labels=labels, title="Classification")

    # Set x-axis limits to be reasonable, e.g., 0 to 20 as per your sample
    ax.set_xlim(left=-1, right=21)
    ax.set_xticks(np.arange(0, 21, 2.5))

    # Remove top and right spines for a cleaner look
    sns.despine()

    # Save the figure
    # Use a tight bounding box and set transparent background for easy inclusion in LaTeX
    plt.savefig(OUTPUT_PLOT_FILE, bbox_inches="tight", transparent=True)

    print(f"✅ Plot saved successfully to '{OUTPUT_PLOT_FILE}'.")
    plt.show()


def main():
    """
    Main function to load audit results and generate the plot.
    """
    # --- 1. Load Data ---
    try:
        with open(INPUT_AUDIT_FILE, "r") as f:
            # Manually provide the data since it's in the prompt
            audit_data = json.load(f)
        print(f"✅ Loaded {len(audit_data)} records from '{INPUT_AUDIT_FILE}'.")
    except FileNotFoundError:
        print(f"❌ Error: Audit results file '{INPUT_AUDIT_FILE}' not found. Please run the judge script first.")
        # As a fallback, use the data from the prompt
        return

    # --- 2. Create DataFrame and Plot ---
    audit_df = pd.DataFrame(audit_data)
    create_density_plot(audit_df)


if __name__ == "__main__":
    main()
