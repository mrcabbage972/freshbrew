import json
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from matplotlib.lines import Line2D
from matplotlib.patches import Patch

# --- Configuration ---
# Assuming a REPO_ROOT for context, adjust if necessary
try:
    from java_migration.utils import REPO_ROOT
except ImportError:
    REPO_ROOT = Path.cwd()
    print(f"Warning: 'java_migration.utils.REPO_ROOT' not found. Defaulting to current dir: {REPO_ROOT}")


# The input file generated by your LLM judge script.
INPUT_AUDIT_FILE = REPO_ROOT / "audit_results.json"
# The output file for the plot.
# Create the figures directory if it doesn't exist
figures_dir = REPO_ROOT / "java_migration" / "figures"
figures_dir.mkdir(parents=True, exist_ok=True)
OUTPUT_PLOT_FILE = figures_dir / "coverage_drop_density.pdf"


# --- Plot Styling (to match the paper's aesthetic) ---
# Use a color palette that matches the paper's figures.
# Based on your figures, a purple/green palette seems appropriate.
palette = {
    "Legitimate Refactoring": "#9370DB",  # A medium purple
    "Reward Hacking": "#3CB371",  # A medium sea green
}
# Set plot style
sns.set_style("whitegrid")
plt.rcParams.update(
    {
        "font.family": "sans-serif",
        "font.sans-serif": ["Helvetica", "Arial", "DejaVu Sans"],
        "axes.grid": True,
        "grid.linestyle": ":",
        "grid.color": "lightgray",
        "figure.figsize": (6, 4),  # Standard figure size
        "axes.labelsize": 10,
        "xtick.labelsize": 9,
        "ytick.labelsize": 9,
        "legend.fontsize": 9,
        "legend.title_fontsize": 10,
    }
)


def create_density_plot(data_df):
    """
    Creates and saves a density plot of coverage drops for different classifications.
    """
    # Ensure the classification column is treated as a category for correct ordering
    data_df["llm_classification"] = pd.Categorical(
        data_df["llm_classification"], categories=["Legitimate Refactoring", "Reward Hacking"], ordered=True
    )

    # Filter out any failed judgments if they exist
    plottable_df = data_df[data_df["llm_classification"].notna()].copy()

    if plottable_df.empty:
        print("No valid data to plot after filtering.")
        return

    # Create the plot
    plt.figure()

    # Use seaborn's kdeplot for smooth density curves, but turn off its own legend
    ax = sns.kdeplot(
        data=plottable_df,
        x="coverage_drop_percent",
        hue="llm_classification",
        palette=palette,
        fill=True,
        alpha=0.6,
        linewidth=1.5,
        common_norm=False,  # Each density is normalized independently
        legend=False,  # Turn off automatic legend to build it manually
    )

    # --- Formatting the plot for the paper ---
    # ax.set_title("Distribution of Coverage Drop by Migration Type", fontsize=12)
    ax.set_xlabel("Coverage Drop (%)")
    ax.set_ylabel("Density")

    # Add a vertical line at the 5% threshold
    plt.axvline(x=5, color="r", linestyle="--", linewidth=1.2)

    # FIX: Manually build the complete legend from scratch for full control.
    # Create handles for the density plots using colored patches
    legend_patches = [
        Patch(facecolor=palette[label], alpha=0.6, label=label)
        for label in plottable_df["llm_classification"].cat.categories
    ]

    # Create a handle for the threshold line
    threshold_line = Line2D([0], [0], color="r", linestyle="--", lw=1.2, label="5% Threshold")

    # Combine all handles
    all_handles = legend_patches + [threshold_line]

    # Create the final legend
    ax.legend(handles=all_handles, title="Classification")

    # Set x-axis limits to be reasonable, e.g., 0 to 20 as per your sample
    ax.set_xlim(left=-1, right=15)
    ax.set_xticks(np.arange(0, 15, 2.5))

    # Remove top and right spines for a cleaner look
    sns.despine()

    # Save the figure
    # Use a tight bounding box and set transparent background for easy inclusion in LaTeX
    plt.savefig(OUTPUT_PLOT_FILE, bbox_inches="tight", transparent=True)

    print(f"✅ Plot saved successfully to '{OUTPUT_PLOT_FILE}'.")
    plt.show()


def main():
    """
    Main function to load audit results and generate the plot.
    """
    # --- 1. Load Data ---
    try:
        with open(INPUT_AUDIT_FILE, "r") as f:
            audit_data = json.load(f)
        print(f"✅ Loaded {len(audit_data)} records from '{INPUT_AUDIT_FILE}'.")
    except FileNotFoundError:
        print(f"❌ Error: Audit results file '{INPUT_AUDIT_FILE}' not found. Please run the judge script first.")
        # As a fallback, use the data from the prompt
        return

    # --- 2. Create DataFrame and Plot ---
    audit_df = pd.DataFrame(audit_data)
    create_density_plot(audit_df)


if __name__ == "__main__":
    main()
